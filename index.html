<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Somnia Tic-Tac-Toe</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Ethers.js CDN for blockchain interaction -->
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.0/dist/ethers.umd.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
        }
        .container {
            max-width: 600px;
        }
        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: 10px;
        }
        .cell {
            width: 100px;
            height: 100px;
            background-color: #2d3748; /* Darker gray for cells */
            color: white;
            font-size: 3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        .cell:not(.disabled):hover {
            background-color: #4a5568; /* Lighter gray on hover */
            transform: scale(1.05);
        }
        .cell.disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }
        .cell-x {
            color: #f56565; /* Red for X */
        }
        .cell-o {
            color: #4299e1; /* Blue for O */
        }
        .bet-button {
            transition: transform 0.1s ease, box-shadow 0.2s ease;
        }
        .bet-button.selected {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border: 2px solid #63b3ed;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">

    <div class="container mx-auto p-8 rounded-lg shadow-2xl bg-gray-800 text-white">

        <!-- Header and Game Title -->
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-indigo-600 mb-2">
                Somnia Tic-Tac-Toe
            </h1>
            <p class="text-gray-400">Play a game against a random AI on the Somnia Testnet</p>
        </div>

        <!-- Bet Selection Section -->
        <div class="flex flex-col items-center mb-8">
            <h2 class="text-xl font-bold mb-4 text-gray-200">Select Your Bet</h2>
            <div id="betting-amounts" class="flex space-x-4">
                <button class="bet-button bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-6 rounded-full shadow-lg" data-bet="0.01">0.01 STT</button>
                <button class="bet-button bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-6 rounded-full shadow-lg" data-bet="0.05">0.05 STT</button>
                <button class="bet-button bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-6 rounded-full shadow-lg" data-bet="0.1">0.1 STT</button>
                <button class="bet-button bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-6 rounded-full shadow-lg" data-bet="1">1 STT</button>
            </div>
        </div>

        <!-- Game Board & Controls -->
        <div class="flex flex-col items-center">
            <div id="game-board" class="board mb-6">
                <!-- Cells will be generated here by JavaScript -->
            </div>
            
            <div id="message-box" class="min-h-[50px] text-center text-lg font-semibold text-yellow-300 mb-6">
                Connect your wallet and select a bet to start.
            </div>

            <button id="startGameBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-10 rounded-full shadow-xl opacity-50 cursor-not-allowed transition" disabled>
                Connect Wallet
            </button>
        </div>
        
        <!-- Credit line -->
        <div class="text-center mt-8 text-gray-400 text-sm">
            Created by <a href="https://x.com/Surya_xyz_" target="_blank" class="text-blue-400 hover:underline">Surya_xyz_</a>
        </div>

    </div>

    <!-- Modal for showing game results and transaction info -->
    <div id="resultModal" class="fixed inset-0 z-50 flex items-center justify-center bg-gray-900 bg-opacity-75 hidden">
        <div class="bg-gray-800 p-8 rounded-lg shadow-2xl max-w-sm w-full mx-4">
            <h3 id="modalTitle" class="text-2xl font-bold text-center text-white mb-4"></h3>
            <p id="modalMessage" class="text-center text-gray-300 mb-6"></p>
            <div id="modalDetails" class="bg-gray-700 p-4 rounded-md text-sm text-gray-400 hidden">
                <p class="font-bold text-white mb-2">Transaction Status: <span id="txStatus"></span></p>
                <p>Value: <span id="txValue"></span></p>
            </div>
            <div class="flex justify-center mt-6">
                <button id="closeModalBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-6 rounded-full">
                    OK
                </button>
            </div>
        </div>
    </div>


    <script>
        // --- CONSTANTS ---
        const NETWORK_DETAILS = {
            chainName: 'Somnia Testnet',
            chainId: '0xC428', // 50312 in hex
            rpcUrls: ['https://dream-rpc.somnia.network/'],
            nativeCurrency: { name: 'STT', symbol: 'STT', decimals: 18 },
            blockExplorerUrls: ['https://shannon-explorer.somnia.network/'],
        };
        const WINNING_COMBINATIONS = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
            [0, 4, 8], [2, 4, 6]             // Diagonals
        ];

        // --- SMART CONTRACT DETAILS ---
        const CONTRACT_ADDRESS = "0x68E6C08C47542cA2db00443E987273A6270e4568";
        const CONTRACT_ABI = [
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "_winner",
                        "type": "address"
                    },
                    {
                        "internalType": "bool",
                        "name": "_isDraw",
                        "type": "bool"
                    }
                ],
                "name": "endGame",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "stateMutability": "nonpayable",
                "type": "constructor"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "player",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "betAmount",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "string",
                        "name": "outcome",
                        "type": "string"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "payoutAmount",
                        "type": "uint256"
                    }
                ],
                "name": "GameResult",
                "type": "event"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_index",
                        "type": "uint256"
                    },
                    {
                        "internalType": "string",
                        "name": "_marker",
                        "type": "string"
                    }
                ],
                "name": "makeMove",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_betAmount",
                        "type": "uint256"
                    }
                ],
                "name": "startGame",
                "outputs": [],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "stateMutability": "payable",
                "type": "fallback"
            },
            {
                "inputs": [],
                "name": "withdrawFunds",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "stateMutability": "payable",
                "type": "receive"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "name": "board",
                "outputs": [
                    {
                        "internalType": "string",
                        "name": "",
                        "type": "string"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "currentBetAmount",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "currentPlayer",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "gameActive",
                "outputs": [
                    {
                        "internalType": "bool",
                        "name": "",
                        "type": "bool"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "owner",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "name": "playerBalances",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            }
        ];


        // --- DOM ELEMENTS ---
        const gameBoard = document.getElementById('game-board');
        const messageBox = document.getElementById('message-box');
        const startGameBtn = document.getElementById('startGameBtn');
        const betButtons = document.querySelectorAll('.bet-button');
        const resultModal = document.getElementById('resultModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const modalDetails = document.getElementById('modalDetails');
        const txValue = document.getElementById('txValue');
        const txStatus = document.getElementById('txStatus'); // Added for transaction status
        const closeModalBtn = document.getElementById('closeModalBtn');

        // --- GAME STATE VARIABLES ---
        let provider;
        let signer;
        let userAddress;
        let contract; // Ethers.js Contract instance
        let boardState = ['', '', '', '', '', '', '', '', ''];
        let currentPlayer = 'X'; // Player is always 'X'
        let isGameActive = false;
        let betAmount = 0;
        let isWalletConnected = false;

        // --- EVENT LISTENERS ---
        window.onload = () => {
            // Check for MetaMask on page load and set up the initial state
            if (window.ethereum) {
                // Listen for account changes
                window.ethereum.on('accountsChanged', handleAccountsChanged);
                // Listen for network changes
                window.ethereum.on('chainChanged', handleChainChanged);
                // Try to connect automatically if already connected
                connectWallet(true);
                // Initial message to the user
                showMessage('Connect your wallet and select a bet to start.', 'text-yellow-300');
            } else {
                showMessage('Please install MetaMask to play.', 'text-red-400');
                startGameBtn.textContent = 'MetaMask Not Found';
                startGameBtn.disabled = true;
                startGameBtn.classList.add('cursor-not-allowed', 'opacity-50');
            }

            // Set up event listener for the start button
            startGameBtn.addEventListener('click', () => {
                if (!isWalletConnected) {
                    connectWallet();
                } else if (betAmount > 0) {
                    startGame();
                } else {
                    showMessage('Please select a bet amount before starting.', 'text-red-400');
                }
            });

            // Set up event listeners for bet buttons
            betButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const amount = parseFloat(button.getAttribute('data-bet'));
                    setBet(amount, button);
                });
            });

            // Set up event listener for closing the modal
            closeModalBtn.addEventListener('click', () => {
                resultModal.classList.add('hidden');
            });

            createBoard();
        };

        // --- WALLET FUNCTIONS ---
        const handleAccountsChanged = (accounts) => {
            if (accounts.length === 0) {
                console.log('Please connect to MetaMask.');
                userAddress = null;
                isWalletConnected = false;
                showMessage('Wallet Not Connected.', 'text-red-400');
                startGameBtn.textContent = 'Connect Wallet';
                startGameBtn.classList.add('opacity-50', 'cursor-not-allowed');
                startGameBtn.disabled = true;
            } else {
                userAddress = accounts[0];
                isWalletConnected = true;
                showMessage(`Connected to wallet.`, 'text-green-400');
                if (betAmount > 0) {
                    startGameBtn.textContent = 'Start Game';
                    startGameBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    startGameBtn.disabled = false;
                } else {
                    startGameBtn.textContent = 'Select Bet';
                    startGameBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    startGameBtn.disabled = false;
                }
                setTimeout(checkNetwork, 500); // Add a small delay to ensure the network state is updated
            }
        };

        const handleChainChanged = (chainId) => {
            console.log('Chain changed to:', chainId);
            checkNetwork();
        };

        const checkNetwork = async () => {
            if (window.ethereum.chainId !== NETWORK_DETAILS.chainId) {
                showMessage(`Please switch to the ${NETWORK_DETAILS.chainName} network (Chain ID: ${parseInt(NETWORK_DETAILS.chainId, 16)})`, 'text-red-400');
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: NETWORK_DETAILS.chainId }],
                    });
                } catch (switchError) {
                    // This error code indicates that the chain has not been added to MetaMask.
                    if (switchError.code === 4902) {
                        try {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [NETWORK_DETAILS],
                            });
                        } catch (addError) {
                            console.error(addError);
                        }
                    }
                    console.error(switchError);
                }
            } else {
                showMessage(`Connected to ${NETWORK_DETAILS.chainName}.`, 'text-green-400');
            }
        };

        const connectWallet = async (isAutoConnect = false) => {
            if (window.ethereum) {
                try {
                    provider = new ethers.providers.Web3Provider(window.ethereum);
                    signer = provider.getSigner();
                    // Initialize contract instance
                    contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    handleAccountsChanged(accounts);
                } catch (error) {
                    console.error('User rejected connection:', error);
                    if (!isAutoConnect) {
                        showMessage('Wallet connection rejected.', 'text-red-400');
                    }
                }
            }
        };

        // --- GAME LOGIC FUNCTIONS ---
        const createBoard = () => {
            gameBoard.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.setAttribute('data-index', i);
                cell.addEventListener('click', handleCellClick);
                gameBoard.appendChild(cell);
            }
        };

        const handleCellClick = (event) => {
            const cell = event.target;
            const index = cell.getAttribute('data-index');

            // Only allow moves if the game is active and the cell is empty
            if (isGameActive && boardState[index] === '') {
                boardState[index] = currentPlayer;
                cell.textContent = currentPlayer;
                cell.classList.add(`cell-${currentPlayer.toLowerCase()}`, 'disabled');

                if (checkWin()) {
                    endGame(`${currentPlayer} wins!`, userAddress, false); // Pass winner address
                    return;
                }
                if (checkDraw()) {
                    endGame(`It's a draw!`, ethers.constants.AddressZero, true); // Pass zero address for draw
                    return;
                }

                currentPlayer = 'O'; // Switch to computer
                showMessage("Computer's turn...", 'text-gray-200');
                // Disable user clicks while computer thinks
                gameBoard.querySelectorAll('.cell').forEach(c => c.classList.add('disabled'));
                setTimeout(computerMove, 1000);
            }
        };

        const computerMove = () => {
            let moveIndex = -1;
            const availableMoves = boardState
                .map((cell, index) => cell === '' ? index : null)
                .filter(val => val !== null);
            
            // AI always plays strategically (100% strategic chance)
            // 1. Check for winning moves
            for (const combination of WINNING_COMBINATIONS) {
                const [a, b, c] = combination;
                if (boardState[a] === 'O' && boardState[b] === 'O' && boardState[c] === '') moveIndex = c;
                if (boardState[a] === 'O' && boardState[c] === 'O' && boardState[b] === '') moveIndex = b;
                if (boardState[b] === 'O' && boardState[c] === 'O' && boardState[a] === '') moveIndex = a;
                if (moveIndex !== -1) break;
            }

            // 2. Block the player's winning moves
            if (moveIndex === -1) {
                for (const combination of WINNING_COMBINATIONS) {
                    const [a, b, c] = combination;
                    if (boardState[a] === 'X' && boardState[b] === 'X' && boardState[c] === '') moveIndex = c;
                    if (boardState[a] === 'X' && boardState[c] === 'X' && boardState[b] === '') moveIndex = b;
                    if (boardState[b] === 'X' && boardState[c] === 'X' && boardState[a] === '') moveIndex = a;
                    if (moveIndex !== -1) break;
                }
            }

            // 3. Take the center
            if (moveIndex === -1 && boardState[4] === '') {
                moveIndex = 4;
            }

            // 4. Take a corner
            if (moveIndex === -1) {
                const corners = [0, 2, 6, 8];
                const availableCorners = corners.filter(index => boardState[index] === '');
                if (availableCorners.length > 0) {
                    moveIndex = availableCorners[Math.floor(Math.random() * availableCorners.length)];
                }
            }

            // 5. Take any remaining available spot
            if (moveIndex === -1) {
                moveIndex = availableMoves[Math.floor(Math.random() * availableMoves.length)];
            }
            

            boardState[moveIndex] = 'O';
            const cell = gameBoard.querySelector(`[data-index="${moveIndex}"]`);
            cell.textContent = 'O';
            cell.classList.add('cell-o', 'disabled');

            if (checkWin()) {
                endGame('Computer wins!', ethers.constants.AddressZero, false); // Computer wins, no specific winner address for loss
                return;
            }
            if (checkDraw()) {
                endGame(`It's a draw!`, ethers.constants.AddressZero, true);
                return;
            }

            currentPlayer = 'X'; // Switch back to player
            showMessage("Your turn...", 'text-gray-200');
            // Re-enable user clicks
            gameBoard.querySelectorAll('.cell').forEach(c => {
                if (boardState[c.getAttribute('data-index')] === '') {
                    c.classList.remove('disabled');
                }
            });
        };

        const checkWin = () => {
            return WINNING_COMBINATIONS.some(combination => {
                return combination.every(index => {
                    return boardState[index] === currentPlayer;
                });
            });
        };

        const checkDraw = () => {
            return boardState.every(cell => cell !== '');
        };

        const startGame = async () => {
            if (!isWalletConnected) {
                showMessage('Please connect your wallet first.', 'text-red-400');
                return;
            }
            if (betAmount === 0) {
                showMessage('Please select a bet amount.', 'text-red-400');
                return;
            }

            showMessage(`Placing bet of ${betAmount} STT... Confirm in wallet.`, 'text-yellow-300');
            
            try {
                // Convert betAmount to Wei (or smallest unit of STT)
                const valueInWei = ethers.utils.parseEther(betAmount.toString());

                // Call the startGame function on the smart contract
                const tx = await contract.startGame(valueInWei, { value: valueInWei });
                showMessage("Transaction sent! Waiting for confirmation...", 'text-yellow-300');
                await tx.wait(); // Wait for the transaction to be mined
                showMessage(`Bet of ${betAmount} STT placed. Game starting...`, 'text-green-400');

                // Reset game state
                boardState = ['', '', '', '', '', '', '', '', ''];
                currentPlayer = 'X';
                isGameActive = true;

                // Clear the board and remove disabled class
                gameBoard.querySelectorAll('.cell').forEach(cell => {
                    cell.textContent = '';
                    cell.classList.remove('cell-x', 'cell-o', 'disabled');
                });
                
                showMessage("Game started! Your turn...", 'text-gray-200');
                
                // Disable start button during the game
                startGameBtn.disabled = true;
                startGameBtn.classList.add('opacity-50', 'cursor-not-allowed');
                
                // Disable bet buttons during the game
                betButtons.forEach(btn => btn.disabled = true);

            } catch (error) {
                console.error("Error starting game or placing bet:", error);
                showMessage(`Failed to place bet. ${error.message || 'Transaction rejected.'}`, 'text-red-400');
                // Re-enable buttons if transaction fails
                startGameBtn.disabled = false;
                startGameBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                betButtons.forEach(btn => btn.disabled = false);
            }
        };

        const endGame = async (message, winnerAddress, isDraw) => {
            isGameActive = false;
            showMessage(message, 'text-green-400');
            // Disable all cells
            gameBoard.querySelectorAll('.cell').forEach(c => c.classList.add('disabled'));

            // Re-enable start button
            startGameBtn.textContent = 'Restart Game';
            startGameBtn.disabled = false;
            startGameBtn.classList.remove('opacity-50', 'cursor-not-allowed');

            // Re-enable bet buttons
            betButtons.forEach(btn => btn.disabled = false);

            showMessage("Ending game and processing payout...", 'text-yellow-300');
            try {
                // Call the endGame function on the smart contract
                const tx = await contract.endGame(winnerAddress, isDraw);
                showMessage("Payout transaction sent! Waiting for confirmation...", 'text-yellow-300');
                await tx.wait(); // Wait for the transaction to be mined

                let outcomeText = '';
                let payoutValue = 0;
                if (isDraw) {
                    outcomeText = 'Draw';
                    payoutValue = betAmount; // Bet returned
                } else if (winnerAddress === userAddress) { // Assuming user is the 'X' player
                    outcomeText = 'Win';
                    payoutValue = betAmount * 2; // Double payout
                } else {
                    outcomeText = 'Loss';
                    payoutValue = -betAmount; // Lost bet
                }

                showResultModal(`${outcomeText}!`, `Game concluded. Check your wallet for ${payoutValue.toFixed(2)} STT.`, true, payoutValue); // Pass payoutValue
                
            } catch (error) {
                console.error("Error ending game or processing payout:", error);
                showResultModal("Transaction Failed", `Failed to process payout. ${error.message || 'Check console for details.'}`, false, 0); // Indicate failure
            }
        };
        
        const setBet = (amount, button) => {
            betAmount = amount;
            // Remove 'selected' class from all buttons
            betButtons.forEach(btn => btn.classList.remove('selected'));
            // Add 'selected' class to the clicked button
            button.classList.add('selected');
            showMessage(`Bet set to ${betAmount} STT.`, 'text-gray-200');
            if (isWalletConnected) {
                startGameBtn.textContent = 'Start Game';
                startGameBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                startGameBtn.disabled = false;
            }
        };
        
        const showMessage = (message, colorClass = 'text-gray-200') => {
            messageBox.innerHTML = message;
            messageBox.className = `min-h-[50px] text-center text-lg font-semibold mb-6 ${colorClass}`;
        };

        const showResultModal = (title, message, isSuccess, transactionValue) => {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            
            if (isSuccess) {
                txStatus.textContent = 'Success';
                txStatus.classList.remove('text-red-400');
                txStatus.classList.add('text-green-400');
                txValue.textContent = `${transactionValue >= 0 ? '+' : ''}${transactionValue.toFixed(2)} STT`;
            } else {
                txStatus.textContent = 'Failed';
                txStatus.classList.remove('text-green-400');
                txStatus.classList.add('text-red-400');
                txValue.textContent = 'N/A'; // Or specific error value if applicable
            }
            modalDetails.classList.remove('hidden');
            resultModal.classList.remove('hidden');
        };

    </script>
</body>
</html>
