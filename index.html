<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blockchain Tic-Tac-Toe</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.ethers.io/lib/ethers-5.2.umd.min.js"></script>
    <style>
        .board-cell {
            width: 100px;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4rem;
            cursor: pointer;
            border: 2px solid #4B5563;
        }
        .board-cell:hover {
            background-color: #374151;
        }
        .x-mark {
            color: #3B82F6; /* Blue */
        }
        .o-mark {
            color: #EF4444; /* Red */
        }
    </style>
</head>
<body class="bg-gray-900 text-white font-sans p-8">

    <div class="container mx-auto max-w-4xl">
        <h1 class="text-5xl font-bold text-center mb-8 text-blue-400">Blockchain Tic-Tac-Toe</h1>

        <div class="flex justify-between items-center bg-gray-800 p-4 rounded-lg mb-6">
            <div id="wallet-info" class="text-lg">
                <span id="wallet-address" class="truncate max-w-xs block">Connect Wallet to begin...</span>
            </div>
            <button id="connect-wallet-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition-colors duration-200">
                Connect MetaMask
            </button>
        </div>

        <div class="flex justify-center mb-8">
            <div class="grid grid-cols-3 gap-2 border-4 border-gray-600 rounded-lg p-2 bg-gray-800">
                <div class="board-cell" data-row="0" data-col="0"></div>
                <div class="board-cell" data-row="0" data-col="1"></div>
                <div class="board-cell" data-row="0" data-col="2"></div>
                <div class="board-cell" data-row="1" data-col="0"></div>
                <div class="board-cell" data-row="1" data-col="1"></div>
                <div class="board-cell" data-row="1" data-col="2"></div>
                <div class="board-cell" data-row="2" data-col="0"></div>
                <div class="board-cell" data-row="2" data-col="1"></div>
                <div class="board-cell" data-row="2" data-col="2"></div>
            </div>
        </div>

        <div class="bg-gray-800 p-6 rounded-lg text-center">
            <div id="game-status" class="text-3xl font-semibold mb-4 text-yellow-300">Connect your wallet to start.</div>
            <div id="game-controls" class="space-x-4">
                <button id="join-game-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-full transition-colors duration-200 hidden">
                    Join Game
                </button>
                <button id="reset-game-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-full transition-colors duration-200 hidden">
                    Reset Game
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- Your Contract Details ---
        const contractAddress = "0xD8f77553789B3b051a99779FbC12a193d6EDDDFa";
        const contractAbi = [
            {
                "inputs": [],
                "stateMutability": "nonpayable",
                "type": "constructor"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "winner",
                        "type": "address"
                    }
                ],
                "name": "GameEnded",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "player1",
                        "type": "address"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "player2",
                        "type": "address"
                    }
                ],
                "name": "GameStarted",
                "type": "event"
            },
            {
                "inputs": [],
                "name": "joinGame",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "row",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "col",
                        "type": "uint256"
                    }
                ],
                "name": "makeMove",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "player",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "row",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "col",
                        "type": "uint256"
                    }
                ],
                "name": "MoveMade",
                "type": "event"
            },
            {
                "inputs": [],
                "name": "resetGame",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "name": "board",
                "outputs": [
                    {
                        "internalType": "enum TicTacToe.SquareState",
                        "name": "",
                        "type": "uint8"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "currentPlayer",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "gameState",
                "outputs": [
                    {
                        "internalType": "enum TicTacToe.GameState",
                        "name": "",
                        "type": "uint8"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "player1",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "player2",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        // --- Somnia Network Config ---
        const somniaChainId = '0xc548'; // 50312 in hex
        const somniaRpcUrl = 'https://rpc.ankr.com/somnia_testnet';

        // --- Global Variables & Elements ---
        let provider, signer, contract;
        let accounts;

        const connectWalletBtn = document.getElementById('connect-wallet-btn');
        const walletAddressElem = document.getElementById('wallet-address');
        const gameStatusElem = document.getElementById('game-status');
        const boardCells = document.querySelectorAll('.board-cell');
        const joinGameBtn = document.getElementById('join-game-btn');
        const resetGameBtn = document.getElementById('reset-game-btn');
        
        // --- Core Functions ---
        async function connectWallet() {
            if (typeof window.ethereum !== 'undefined') {
                try {
                    const requestedAccounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    accounts = requestedAccounts[0];

                    const currentChainId = await window.ethereum.request({ method: 'eth_chainId' });
                    if (currentChainId !== somniaChainId) {
                        try {
                            await window.ethereum.request({
                                method: 'wallet_switchEthereumChain',
                                params: [{ chainId: somniaChainId }],
                            });
                        } catch (switchError) {
                            if (switchError.code === 4902) {
                                await window.ethereum.request({
                                    method: 'wallet_addEthereumChain',
                                    params: [{
                                        chainId: somniaChainId,
                                        rpcUrls: [somniaRpcUrl],
                                        chainName: 'Somnia Testnet',
                                        nativeCurrency: {
                                            name: 'STT',
                                            symbol: 'STT',
                                            decimals: 18
                                        },
                                        blockExplorerUrls: ['https://shannon-explorer.somnia.network/']
                                    }]
                                });
                            }
                            console.error('Failed to switch to or add Somnia network:', switchError);
                            gameStatusElem.textContent = "Please switch to the Somnia Testnet.";
                            return;
                        }
                    }

                    provider = new ethers.providers.Web3Provider(window.ethereum);
                    signer = provider.getSigner();
                    
                    walletAddressElem.textContent = `Wallet: ${accounts.substring(0, 6)}...${accounts.substring(38)}`;
                    connectWalletBtn.textContent = 'Connected';
                    connectWalletBtn.disabled = true;

                    contract = new ethers.Contract(contractAddress, contractAbi, signer);
                    setupEventListeners();
                    updateGameState();
                } catch (error) {
                    console.error("User rejected request or other error:", error);
                    gameStatusElem.textContent = "Connection failed. Please try again.";
                }
            } else {
                gameStatusElem.textContent = "MetaMask not found. Please install it.";
            }
        }

        function setupEventListeners() {
            contract.on('GameStarted', (player1, player2) => {
                console.log(`Game started between ${player1} and ${player2}`);
                updateGameState();
            });

            contract.on('MoveMade', (player, row, col) => {
                console.log(`${player} made a move at row ${row}, col ${col}`);
                updateGameState();
            });

            contract.on('GameEnded', (winner) => {
                console.log(`Game ended. Winner is ${winner}`);
                updateGameState();
            });

            // Listen for account changes
            if (window.ethereum) {
                window.ethereum.on('accountsChanged', (newAccounts) => {
                    if (newAccounts.length === 0) {
                        window.location.reload();
                    } else {
                        accounts = newAccounts[0];
                        walletAddressElem.textContent = `Wallet: ${accounts.substring(0, 6)}...${accounts.substring(38)}`;
                        signer = provider.getSigner();
                        contract = new ethers.Contract(contractAddress, contractAbi, signer);
                        updateGameState();
                    }
                });
            }
        }

        async function joinGame() {
            try {
                const tx = await contract.joinGame();
                gameStatusElem.textContent = "Joining game...";
                await tx.wait();
                gameStatusElem.textContent = "Joined! Waiting for opponent's turn...";
            } catch (error) {
                console.error("Error joining game:", error);
                gameStatusElem.textContent = "Failed to join. Is a player already connected?";
            }
        }

        async function makeMove(row, col) {
            if (!contract) return;
            try {
                const tx = await contract.makeMove(row, col);
                gameStatusElem.textContent = "Submitting your move...";
                await tx.wait();
                gameStatusElem.textContent = "Move successful! Waiting for opponent...";
            } catch (error) {
                console.error("Error making move:", error);
                gameStatusElem.textContent = "Failed to make move. Is it your turn or is the cell already taken?";
            }
        }

        async function resetGame() {
            try {
                const tx = await contract.resetGame();
                gameStatusElem.textContent = "Resetting game...";
                await tx.wait();
                gameStatusElem.textContent = "Game reset! A new round begins.";
            } catch (error) {
                console.error("Error resetting game:", error);
                gameStatusElem.textContent = "Failed to reset. Only players can reset a finished game.";
            }
        }

        async function updateGameState() {
            if (!contract) return;

            try {
                const [p1, p2, cPlayer, gState] = await Promise.all([
                    contract.player1(),
                    contract.player2(),
                    contract.currentPlayer(),
                    contract.gameState()
                ]);

                // Update UI based on game state
                joinGameBtn.style.display = 'none';
                resetGameBtn.style.display = 'none';

                if (gState == 0) { // WaitingForPlayer
                    gameStatusElem.textContent = "Waiting for a second player to join...";
                    if (accounts && accounts.toLowerCase() !== p1.toLowerCase() && p2 === "0x0000000000000000000000000000000000000000") {
                        joinGameBtn.style.display = 'inline-block';
                    }
                } else if (gState == 1) { // InProgress
                    const isMyTurn = accounts && accounts.toLowerCase() === cPlayer.toLowerCase();
                    gameStatusElem.textContent = isMyTurn ? "Your turn!" : "Opponent's turn...";
                } else if (gState == 2) { // Player1Won
                    gameStatusElem.textContent = `Player 1 (${p1.substring(0, 6)}...) wins!`;
                    resetGameBtn.style.display = 'inline-block';
                } else if (gState == 3) { // Player2Won
                    gameStatusElem.textContent = `Player 2 (${p2.substring(0, 6)}...) wins!`;
                    resetGameBtn.style.display = 'inline-block';
                } else if (gState == 4) { // Draw
                    gameStatusElem.textContent = "It's a draw!";
                    resetGameBtn.style.display = 'inline-block';
                }

                // Update the board
                const boardReads = [];
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        boardReads.push(contract.board(i, j));
                    }
                }
                const boardStates = await Promise.all(boardReads);

                boardCells.forEach((cell, index) => {
                    const squareState = boardStates[index];
                    cell.textContent = '';
                    cell.className = 'board-cell'; // Reset class
                    if (squareState == 1) { // Player1
                        cell.textContent = 'X';
                        cell.classList.add('x-mark');
                    } else if (squareState == 2) { // Player2
                        cell.textContent = 'O';
                        cell.classList.add('o-mark');
                    }
                });
            } catch (error) {
                console.error("Error updating game state:", error);
                gameStatusElem.textContent = "Error fetching game state. Please check your connection.";
            }
        }

        // --- Event Listeners ---
        connectWalletBtn.addEventListener('click', connectWallet);
        joinGameBtn.addEventListener('click', joinGame);
        resetGameBtn.addEventListener('click', resetGame);

        boardCells.forEach(cell => {
            cell.addEventListener('click', (e) => {
                if (contract) {
                    const row = e.target.dataset.row;
                    const col = e.target.dataset.col;
                    makeMove(row, col);
                } else {
                    gameStatusElem.textContent = "Please connect your wallet first.";
                }
            });
        });
    </script>
</body>
</html>
