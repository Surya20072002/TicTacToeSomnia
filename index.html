<script>
        // --- Network and DApp Configuration ---
        const somniaNetwork = {
            chainId: '0xC488', // 50312 in hex
            chainName: 'Somnia Testnet',
            rpcUrls: ['https://dream-rpc.somnia.network/'],
            nativeCurrency: { name: 'STT', symbol: 'STT', decimals: 18 },
            blockExplorerUrls: ['https://shannon-explorer.somnia.network/']
        };

        // --- Contract Details (Make sure these match your deployed contract) ---
        const CONTRACT_ADDRESS = "0xa64DB90b1F1CF2D39ce14b7d8Af2690640dDED0d";
        const CONTRACT_ABI = [
            // Your ABI here
            {
                "inputs": [],
                "stateMutability": "nonpayable",
                "type": "constructor"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "winner",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "enum TicTacToe.GameState",
                        "name": "state",
                        "type": "uint8"
                    }
                ],
                "name": "GameEnded",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "playerX",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "betAmount",
                        "type": "uint256"
                    }
                ],
                "name": "GameStarted",
                "type": "event"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint8",
                        "name": "_index",
                        "type": "uint8"
                    }
                ],
                "name": "makeMove",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "player",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint8",
                        "name": "index",
                        "type": "uint8"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint8",
                        "name": "playerMark",
                        "type": "uint8"
                    }
                ],
                "name": "MoveMade",
                "type": "event"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_betAmount",
                        "type": "uint256"
                    }
                ],
                "name": "startGame",
                "outputs": [],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "betAmount",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "name": "board",
                "outputs": [
                    {
                        "internalType": "uint8",
                        "name": "",
                        "type": "uint8"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "movesMade",
                "outputs": [
                    {
                        "internalType": "uint8",
                        "name": "",
                        "type": "uint8"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "playerX",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "state",
                "outputs": [
                    {
                        "internalType": "enum TicTacToe.GameState",
                        "name": "",
                        "type": "uint8"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "turn",
                "outputs": [
                    {
                        "internalType": "uint8",
                        "name": "",
                        "type": "uint8"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "winner",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        // --- DOM Elements and Global State ---
        const statusElement = document.getElementById("status");
        const connectWalletButton = document.getElementById("connect-wallet-button");
        const bettingSection = document.getElementById("betting-section");
        const startButton = document.getElementById("start-game-button");
        const betButtons = document.querySelectorAll(".bet-button");
        const boardElement = document.getElementById("game-board");
        const messageBox = document.getElementById("message-box");

        let signer;
        let contract;
        let selectedBetAmount = 0;
        let userAddress;
        let isWalletConnected = false;

        // --- Wallet Connection and Network Handling ---
        const switchNetwork = async () => {
             if (window.ethereum) {
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: somniaNetwork.chainId }],
                    });
                } catch (switchError) {
                    if (switchError.code === 4902) {
                        try {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: somniaNetwork.chainId,
                                    rpcUrls: somniaNetwork.rpcUrls,
                                    chainName: somniaNetwork.chainName,
                                    nativeCurrency: somniaNetwork.nativeCurrency,
                                    blockExplorerUrls: somniaNetwork.blockExplorerUrls,
                                }],
                            });
                        } catch (addError) {
                            console.error("Failed to add network:", addError);
                            messageBox.textContent = "Failed to add network to MetaMask.";
                        }
                    } else {
                        console.error("Failed to switch network:", switchError);
                        messageBox.textContent = "Failed to switch network.";
                    }
                }
            }
        };

        const connectWallet = async () => {
            if (window.ethereum) {
                try {
                    messageBox.textContent = "Connecting...";
                    messageBox.classList.remove('hidden');

                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    userAddress = accounts[0];
                    isWalletConnected = true;

                    const provider = new ethers.providers.Web3Provider(window.ethereum);
                    const { chainId } = await provider.getNetwork();
                    
                    if (chainId === parseInt(somniaNetwork.chainId)) {
                        signer = provider.getSigner();
                        contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
                        
                        connectWalletButton.classList.add('hidden');
                        bettingSection.classList.remove('hidden');
                        messageBox.textContent = `Wallet connected: ${userAddress.substring(0, 6)}...`;
                        console.log("Wallet connected:", userAddress);
                        updateUI();
                    } else {
                        isWalletConnected = false;
                        connectWalletButton.textContent = "Switch Network";
                        connectWalletButton.classList.remove('hidden');
                        bettingSection.classList.add('hidden');
                        messageBox.textContent = "Wrong network. Please switch to Somnia Testnet.";
                        connectWalletButton.removeEventListener('click', connectWallet);
                        connectWalletButton.addEventListener('click', switchNetwork);
                    }
                } catch (error) {
                    console.error("Connection failed:", error);
                    messageBox.textContent = "Connection to wallet failed.";
                }
            } else {
                messageBox.textContent = "MetaMask or another wallet is not installed. Please install one.";
                connectWalletButton.classList.add('hidden');
            }
        };

        const disconnectWallet = () => {
            userAddress = null;
            isWalletConnected = false;
            signer = null;
            contract = null;
            connectWalletButton.textContent = "Connect Wallet";
            connectWalletButton.classList.remove('hidden');
            bettingSection.classList.add('hidden');
            messageBox.textContent = "Wallet disconnected.";
            connectWalletButton.removeEventListener('click', switchNetwork);
            connectWalletButton.addEventListener('click', connectWallet);
        };
        
        // --- Game Logic ---

        // Renders the game board
        function renderBoard() {
            boardElement.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement("div");
                cell.classList.add("cell");
                cell.dataset.index = i;
                cell.addEventListener("click", handleCellClick);
                boardElement.appendChild(cell);
            }
        }

        // Handles a player's move
        async function handleCellClick(event) {
            if (!contract || !isWalletConnected) {
                messageBox.textContent = "Please connect your wallet first.";
                return;
            }

            const currentState = await contract.state();
            if (currentState !== 0) {
                messageBox.textContent = "Game is not active.";
                return;
            }

            const cellIndex = parseInt(event.target.dataset.index);
            const currentBoard = await getBoardState();
            
            if (currentBoard[cellIndex] !== 0) {
                messageBox.textContent = "This spot is already taken!";
                return;
            }

            messageBox.textContent = "Making your move... Please confirm transaction.";
            try {
                const tx = await contract.makeMove(cellIndex);
                await tx.wait();
                messageBox.textContent = "Move successful. Waiting for AI's move.";
                updateUI();
            } catch (error) {
                console.error("Error making move:", error);
                messageBox.textContent = `Error making move: ${error.message || "Check console"}`;
            }
        }

        // Fetches the current board state from the contract
        async function getBoardState() {
            const board = [];
            for (let i = 0; i < 9; i++) {
                const cellValue = await contract.board(i);
                board.push(cellValue.toNumber());
            }
            return board;
        }

        // Updates the UI based on the game's state
        async function updateUI() {
            if (!contract) return;
            
            const currentState = await contract.state();
            const currentBoard = await getBoardState();
            
            const cells = document.querySelectorAll('.cell');
            if (cells.length === 0) renderBoard();
            
            cells.forEach((cell, index) => {
                const value = currentBoard[index];
                cell.dataset.player = value;
                cell.textContent = value === 1 ? 'X' : value === 2 ? 'O' : '';
            });

            if (currentState === 0) {
                const playerXAddress = await contract.playerX();
                const currentTurn = await contract.turn();
                
                if (currentTurn === 1) {
                    statusElement.textContent = userAddress && userAddress.toLowerCase() === playerXAddress.toLowerCase() ? "Your turn (X)." : "Waiting for Player X's move.";
                } else {
                    statusElement.textContent = "AI is thinking...";
                }
            } else {
                const winnerAddress = await contract.winner();
                if (currentState === 1) {
                    statusElement.textContent = winnerAddress && winnerAddress.toLowerCase() === userAddress.toLowerCase() ? "You won! ðŸŽ‰" : "Player X won!";
                } else if (currentState === 2) {
                    statusElement.textContent = "AI won. Better luck next time!";
                } else if (currentState === 3) {
                    statusElement.textContent = "It's a draw! ðŸ¤";
                }
                setTimeout(() => {
                    bettingSection.classList.remove('hidden');
                    startButton.disabled = true;
                    selectedBetAmount = 0;
                    document.querySelector('.bet-button.selected')?.classList.remove('selected');
                    boardElement.innerHTML = '';
                    statusElement.textContent = "Game Over. Start a new one!";
                }, 5000);
            }
        }
        
        // --- Event Listeners and Initial Setup ---
        
        // Event listener for connect wallet button
        connectWalletButton.addEventListener("click", connectWallet);

        // Event listener for bet buttons
        betButtons.forEach(button => {
            button.addEventListener("click", () => {
                betButtons.forEach(btn => btn.classList.remove('selected'));
                button.classList.add('selected');
                selectedBetAmount = parseFloat(button.dataset.value);
                startButton.disabled = false;
            });
        });

        // Event listener for start game button
        startButton.addEventListener("click", async () => {
            if (selectedBetAmount > 0 && contract) {
                try {
                    const betInWei = ethers.utils.parseEther(selectedBetAmount.toString());
                    messageBox.textContent = "Starting game... Please confirm transaction.";
                    const tx = await contract.startGame(betInWei, { value: betInWei });
                    await tx.wait();
                    messageBox.textContent = "Game started! Your turn (X).";
                    bettingSection.classList.add('hidden');
                    updateUI();
                } catch (error) {
                    console.error("Error starting game:", error);
                    messageBox.textContent = `Error starting game: ${error.message || "Check console"}`;
                }
            }
        });

        // Event listeners for wallet provider events
        if (window.ethereum) {
            window.ethereum.on('accountsChanged', (accounts) => {
                if (accounts.length > 0) {
                    userAddress = accounts[0];
                    connectWallet();
                } else {
                    disconnectWallet();
                }
            });
            window.ethereum.on('chainChanged', () => {
                location.reload();
            });

            // Watch for contract events
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const contractWithProvider = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, provider);

            contractWithProvider.on("GameStarted", () => updateUI());
            contractWithProvider.on("MoveMade", () => updateUI());
            contractWithProvider.on("GameEnded", () => updateUI());
        }

        // Initial check on page load
        window.onload = () => {
            setTimeout(() => {
                if (window.ethereum) {
                    connectWallet();
                } else {
                    statusElement.textContent = "MetaMask not found. Please install it.";
                    connectWalletButton.classList.remove('hidden');
                }
            }, 500); // Add a 500ms delay to give MetaMask time to load
        };
    </script>
</body>
</html>
