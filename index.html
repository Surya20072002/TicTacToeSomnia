import { useState, useEffect } from 'react';
import { Buffer } from 'buffer';

// Fix for Buffer not being defined
if (typeof window !== 'undefined') {
  window.Buffer = Buffer;
}

// Somnia Testnet Configuration
const somniaTestnet = {
  id: 50312,
  name: 'Somnia Testnet',
  network: 'somnia-testnet',
  nativeCurrency: {
    decimals: 18,
    name: 'STT',
    symbol: 'STT',
  },
  rpcUrls: {
    default: {
      http: ['https://dream-rpc.somnia.network/'],
    },
    public: {
      http: ['https://dream-rpc.somnia.network/'],
    },
  },
  blockExplorers: {
    default: {
      name: 'Somnia Explorer',
      url: 'https://shannon-explorer.somnia.network/',
    },
  },
  testnet: true,
};

// Replace with your deployed contract address and ABI after deployment.
const CONTRACT_ADDRESS = '0x5FbDB2315678afecb367f032d93F642f64180aa3'; // Placeholder
const CONTRACT_ABI = [
  // ABI from the MysteryMine.sol contract
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "player",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "bool",
        "name": "won",
        "type": "bool"
      }
    ],
    "name": "GameOver",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "player",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint8",
        "name": "size",
        "type": "uint8"
      },
      {
        "indexed": false,
        "internalType": "uint8",
        "name": "mines",
        "type": "uint8"
      }
    ],
    "name": "GameStarted",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "player",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint8",
        "name": "x",
        "type": "uint8"
      },
      {
        "indexed": false,
        "internalType": "uint8",
        "name": "y",
        "type": "uint8"
      },
      {
        "indexed": false,
        "internalType": "uint8",
        "name": "value",
        "type": "uint8"
      }
    ],
    "name": "TileRevealed",
    "type": "event"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "leaderboard",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint8",
        "name": "size",
        "type": "uint8"
      },
      {
        "internalType": "uint8",
        "name": "mines",
        "type": "uint8"
      },
      {
        "internalType": "string",
        "name": "seed",
        "type": "string"
      }
    ],
    "name": "newGame",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "playerGames",
    "outputs": [
      {
        "internalType": "uint8",
        "name": "size",
        "type": "uint8"
      },
      {
        "internalType": "uint8",
        "name": "mines",
        "type": "uint8"
      },
      {
        "internalType": "uint8",
        "name": "tilesRevealed",
        "type": "uint8"
      },
      {
        "internalType": "uint256",
        "name": "score",
        "type": "uint256"
      },
      {
        "internalType": "bool",
        "name": "active",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint8",
        "name": "x",
        "type": "uint8"
      },
      {
        "internalType": "uint8",
        "name": "y",
        "type": "uint8"
      }
    ],
    "name": "revealTile",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getGameState",
    "outputs": [
      {
        "internalType": "uint8",
        "name": "size",
        "type": "uint8"
      },
      {
        "internalType": "uint8",
        "name": "mines",
        "type": "uint8"
      },
      {
        "internalType": "uint8",
        "name": "tilesRevealed",
        "type": "uint8"
      },
      {
        "internalType": "bool",
        "name": "active",
        "type": "bool"
      },
      {
        "internalType": "uint8[]",
        "name": "board",
        "type": "uint8[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getMyHighScore",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
];

function App() {
  const [address, setAddress] = useState(null);
  const [boardSize, setBoardSize] = useState(9);
  const [board, setBoard] = useState([]);
  const [gameStatus, setGameStatus] = useState('Welcome! Choose a difficulty and start a new game.');
  const [isLoading, setIsLoading] = useState(false);
  const [highScore, setHighScore] = useState(0);

  // Helper function to encode a string to hex
  const stringToHex = (str) => {
    let hex = '';
    for (let i = 0; i < str.length; i++) {
      hex += str.charCodeAt(i).toString(16).padStart(2, '0');
    }
    return hex;
  };

  // Helper function to manually encode function call data
  const encodeFunctionData = (functionName, types, values) => {
    // This is a simplified manual encoder. For real-world use, a library is highly recommended.
    // We'll hardcode the function selectors for simplicity.
    let functionSignature = '';
    if (functionName === 'newGame') {
      functionSignature = '0x1634b079'; // keccak256('newGame(uint8,uint8,string)')
    } else if (functionName === 'revealTile') {
      functionSignature = '0x15392095'; // keccak256('revealTile(uint8,uint8)')
    } else if (functionName === 'getGameState') {
      functionSignature = '0x1b4ae839'; // keccak256('getGameState()')
    } else if (functionName === 'getMyHighScore') {
        functionSignature = '0x12a97187'; // keccak256('getMyHighScore()')
    } else {
      throw new Error(`Unknown function name: ${functionName}`);
    }

    let encodedArgs = '';
    let dynamicDataOffset = types.length * 32;

    for (let i = 0; i < types.length; i++) {
      const type = types[i];
      const value = values[i];

      if (type === 'uint8') {
        encodedArgs += value.toString(16).padStart(64, '0');
      } else if (type === 'string') {
        const hexString = stringToHex(value);
        const length = hexString.length / 2;
        encodedArgs += dynamicDataOffset.toString(16).padStart(64, '0');
        encodedArgs += length.toString(16).padStart(64, '0');
        encodedArgs += hexString.padEnd(Math.ceil(hexString.length / 64) * 64, '0');
        dynamicDataOffset += (32 + Math.ceil(hexString.length / 64) * 32);
      }
    }
    return functionSignature + encodedArgs;
  };

  // Function to connect to wallet using window.ethereum
  const connectWallet = async () => {
    try {
      if (typeof window.ethereum !== 'undefined') {
        const accounts = await window.ethereum.request({
          method: 'eth_requestAccounts',
        });
        if (accounts.length > 0) {
          setAddress(accounts[0]);
          console.log("Connected with account:", accounts[0]);
        }
      } else {
        const messageBox = document.createElement('div');
        messageBox.innerHTML = 'Please install a wallet like MetaMask to play.';
        messageBox.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background-color: white;
          padding: 2rem;
          border-radius: 1rem;
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
          z-index: 1000;
          text-align: center;
        `;
        document.body.appendChild(messageBox);
        setTimeout(() => document.body.removeChild(messageBox), 3000);
      }
    } catch (error) {
      console.error("Could not connect wallet:", error);
    }
  };

  // Helper function to handle sending transactions
  const sendTransaction = async (data, value = '0x0') => {
    if (!address) {
      throw new Error('No wallet connected');
    }
    const transactionParameters = {
      to: CONTRACT_ADDRESS,
      from: address,
      data: data,
      value: value,
      chainId: `0x${somniaTestnet.id.toString(16)}`,
    };
    try {
      const txHash = await window.ethereum.request({
        method: 'eth_sendTransaction',
        params: [transactionParameters],
      });
      console.log('Transaction sent:', txHash);
      return txHash;
    } catch (error) {
      console.error('Failed to send transaction:', error);
      throw error;
    }
  };

  // Helper function to handle read-only contract calls
  const readContract = async (data) => {
    try {
      const result = await window.ethereum.request({
        method: 'eth_call',
        params: [{
          to: CONTRACT_ADDRESS,
          data: data,
          from: address,
        }, 'latest'],
      });
      return result;
    } catch (error) {
      console.error('Failed to read contract:', error);
      throw error;
    }
  };

  const fetchGameState = async () => {
    if (!address) return;
    setIsLoading(true);
    try {
      const callData = encodeFunctionData('getGameState', [], []);
      const result = await readContract(callData);

      // Manual decoding for getGameState() return (uint8, uint8, uint8, bool, uint8[])
      const boardDataOffset = parseInt(result.substring(2 + 4 * 64, 2 + 5 * 64), 16) * 2;
      const boardLength = parseInt(result.substring(boardDataOffset, boardDataOffset + 64), 16);
      const boardArrayHex = result.substring(boardDataOffset + 64);
      
      const boardArray = [];
      for(let i = 0; i < boardLength; i++) {
          boardArray.push(parseInt(boardArrayHex.substring(i * 64 + 2, (i + 1) * 64), 16));
      }

      const size = parseInt(result.substring(2, 2 + 64), 16);
      const mines = parseInt(result.substring(2 + 64, 2 + 2 * 64), 16);
      const tiles = parseInt(result.substring(2 + 2 * 64, 2 + 3 * 64), 16);
      const active = parseInt(result.substring(2 + 3 * 64, 2 + 4 * 64), 16) === 1;

      if (active) {
        setBoardSize(size);
        setBoard(boardArray);
        setGameStatus('Game in progress...');
        
        const myHighScoreCallData = encodeFunctionData('getMyHighScore', [], []);
        const highScoreResult = await readContract(myHighScoreCallData);
        setHighScore(parseInt(highScoreResult, 16));
      } else {
        setGameStatus('No active game. Start a new one!');
        setBoard([]);
      }
    } catch (error) {
      console.error('Error fetching game state:', error);
      setGameStatus('Error fetching game state. Please check console.');
    } finally {
      setIsLoading(false);
    }
  };

  const startNewGame = async (size, mines) => {
    if (!address || isLoading) return;
    setIsLoading(true);
    try {
      const seed = Math.random().toString(36).substring(2, 15);
      const callData = encodeFunctionData('newGame', ['uint8', 'uint8', 'string'], [size, mines, seed]);
      const txHash = await sendTransaction(callData);
      setGameStatus(`New game started! Transaction: ${txHash}. Waiting for confirmation...`);
      // A simple poll to wait for the transaction to be mined.
      setTimeout(() => fetchGameState(), 5000);
    } catch (error) {
      console.error('Error starting new game:', error);
      setGameStatus('Error starting game. Please check console.');
    } finally {
      setIsLoading(false);
    }
  };

  const revealTile = async (x, y) => {
    if (!address || isLoading) return;
    setIsLoading(true);
    try {
      const callData = encodeFunctionData('revealTile', ['uint8', 'uint8'], [x, y]);
      const txHash = await sendTransaction(callData);
      setGameStatus(`Revealing tile (${x}, ${y}). Transaction: ${txHash}. Waiting for confirmation...`);
      // A simple poll to wait for the transaction to be mined.
      setTimeout(() => fetchGameState(), 5000);
    } catch (error) {
      console.error('Error revealing tile:', error);
      setGameStatus('Error revealing tile. Please check console.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    if (address) {
      fetchGameState();
    }
  }, [address]);

  const renderBoard = () => {
    if (board.length === 0) return null;
    return (
      <div
        className="grid gap-1 m-4"
        style={{
          gridTemplateColumns: `repeat(${boardSize}, minmax(0, 1fr))`,
          width: 'min(90vw, 500px)',
        }}
      >
        {board.map((tileValue, index) => {
          const x = Math.floor(index / boardSize);
          const y = index % boardSize;
          // The board array from the contract returns the actual tile value.
          // 10 is used to represent a revealed tile, 9 is a mine.
          const isRevealed = tileValue >= 0 && tileValue <= 8; 
          const isMine = tileValue === 9;

          return (
            <button
              key={index}
              className={`
                aspect-square rounded-md shadow-inner transition-colors duration-200
                ${isRevealed ? 'bg-gray-200 text-gray-700' : 'bg-somnia-accent hover:bg-somnia-accent-light text-white'}
                ${isMine ? 'bg-red-500' : ''}
              `}
              onClick={() => !isRevealed && !isMine && revealTile(x, y)}
              disabled={isLoading || isRevealed || isMine || !gameStatus.includes('in progress')}
            >
              {isRevealed && (
                <span className="font-bold text-lg">
                  {tileValue > 0 ? tileValue : ''}
                </span>
              )}
              {isMine && <span className="text-xl">💣</span>}
            </button>
          );
        })}
      </div>
    );
  };
  
  return (
    <div className="min-h-screen bg-somnia-bg text-somnia-text font-sans flex flex-col items-center justify-center p-4">
      <div className="bg-white p-6 rounded-3xl shadow-xl max-w-xl w-full text-center">
        <h1 className="text-4xl font-bold text-somnia-text mb-4">Mystery Mine</h1>
        
        <div className="mb-4">
          <button
            onClick={connectWallet}
            className="px-6 py-3 bg-somnia-primary text-white rounded-full shadow-lg hover:bg-somnia-secondary transition duration-300 transform hover:scale-105"
          >
            {address ? `Connected: ${address.slice(0, 6)}...${address.slice(-4)}` : 'Connect Wallet'}
          </button>
        </div>
        
        {address && (
          <div className="mb-6">
            <h2 className="text-2xl font-semibold mb-2">Game Controls</h2>
            <div className="flex justify-center space-x-4 mb-4">
              <button
                onClick={() => startNewGame(9, 10)}
                disabled={isLoading}
                className="px-4 py-2 bg-purple-500 text-white rounded-full shadow-md hover:bg-purple-600 transition duration-300"
              >
                Easy (9x9, 10 mines)
              </button>
              <button
                onClick={() => startNewGame(16, 40)}
                disabled={isLoading}
                className="px-4 py-2 bg-indigo-500 text-white rounded-full shadow-md hover:bg-indigo-600 transition duration-300"
              >
                Medium (16x16, 40 mines)
              </button>
            </div>
            
            <p className="text-lg font-medium text-gray-600">Status: {gameStatus}</p>
            {isLoading && (
              <div className="mt-2 text-somnia-secondary animate-pulse">Processing transaction...</div>
            )}
            <p className="text-xl font-bold mt-2">High Score: {highScore.toString()}</p>
          </div>
        )}
        
        {renderBoard()}
      </div>
    </div>
  );
}

// Tailwind CSS for Somnia branding (assuming Somnia has brand colors)
const tailwindConfig = {
  theme: {
    extend: {
      colors: {
        'somnia-bg': '#f3f4f6',
        'somnia-text': '#1f2937',
        'somnia-primary': '#4f46e5', // A deep purple
        'somnia-secondary': '#6366f1', // A lighter purple
        'somnia-accent': '#c4b5fd', // A very light purple/lavender
        'somnia-accent-light': '#ddd6fe',
      },
      fontFamily: {
        sans: ['Inter', 'sans-serif'],
      },
    },
  },
};

export default App;
