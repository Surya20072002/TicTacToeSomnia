<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic Tac Toe on Somnia Network</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Ethers.js CDN for Web3 interaction -->
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        .game-container {
            background-color: #2d3748; /* Darker background for container */
            border-radius: 1rem; /* Rounded corners */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            padding: 2.5rem;
            width: 100%;
            max-width: 500px;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 0.5rem;
            width: 100%;
            aspect-ratio: 1 / 1; /* Make it square */
            max-width: 300px; /* Max width for the board */
            margin: 0 auto;
        }

        .cell {
            width: 100%;
            height: 100%;
            background-color: #4a5568; /* Cell background */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3rem;
            font-weight: bold;
            cursor: pointer;
            border-radius: 0.5rem;
            transition: background-color 0.2s ease-in-out;
            color: #a0aec0; /* Default cell content color */
        }

        .cell:hover:not(.occupied) {
            background-color: #636b7d; /* Hover effect */
        }

        .cell.occupied {
            cursor: not-allowed;
        }

        .cell.x {
            color: #f56565; /* Red for X */
        }

        .cell.o {
            color: #63b3ed; /* Blue for O */
        }

        .button-group button {
            @apply px-6 py-3 rounded-xl font-semibold transition-all duration-200 ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .button-group button:hover {
            @apply transform -translate-y-1;
        }

        .btn-primary {
            @apply bg-blue-600 text-white;
        }

        .btn-primary:hover {
            @apply bg-blue-700;
        }

        .btn-secondary {
            @apply bg-gray-600 text-white;
        }

        .btn-secondary:hover {
            @apply bg-gray-700;
        }

        .bet-option {
            @apply bg-purple-600 text-white;
        }

        .bet-option:hover {
            @apply bg-purple-700;
        }

        .message-box {
            background-color: #4a5568;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
            font-size: 0.9rem;
            color: #cbd5e0;
            text-align: left;
        }

        .message-box.error {
            background-color: #c53030;
            color: #fff;
        }

        .message-box.success {
            background-color: #38a169;
            color: #fff;
        }

        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #63b3ed;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-left: 8px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex items-center justify-center min-h-screen p-4">
    <div class="game-container">
        <h1 class="text-4xl font-extrabold text-blue-400 mb-4">Tic Tac Toe</h1>
        <p class="text-xl font-semibold mb-2" id="status-message">Connect your wallet to play!</p>
        <p class="text-sm text-gray-400" id="account-info"></p>
        <p class="text-sm text-gray-400" id="game-id-display"></p>

        <div id="betting-section" class="flex flex-wrap justify-center gap-3 mb-4">
            <button class="bet-option px-5 py-2" data-bet="0.01">Bet 0.01 STT</button>
            <button class="bet-option px-5 py-2" data-bet="0.05">Bet 0.05 STT</button>
            <button class="bet-option px-5 py-2" data-bet="0.5">Bet 0.5 STT</button>
            <button class="bet-option px-5 py-2" data-bet="1">Bet 1 STT</button>
        </div>

        <div id="game-actions" class="flex justify-center gap-4 mb-4 hidden">
            <button id="join-game-btn" class="btn-primary">Join Game</button>
            <button id="claim-winnings-btn" class="btn-secondary">Claim Winnings</button>
            <button id="reset-game-btn" class="btn-secondary">Reset Game</button>
        </div>

        <div class="game-board" id="game-board">
            <!-- Cells will be dynamically generated here -->
        </div>

        <div id="message-box" class="message-box hidden"></div>
    </div>

    <script>
        // Contract configuration
        const CONTRACT_ADDRESS = "0x0476b50369681e36d54e809090BE83810022B4f3";
        const CONTRACT_ABI = [
            {
                "inputs": [],
                "name": "claimWinnings",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "_winner",
                        "type": "address"
                    },
                    {
                        "internalType": "bool",
                        "name": "_isDraw",
                        "type": "bool"
                    }
                ],
                "name": "concludeGame",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "stateMutability": "nonpayable",
                "type": "constructor"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "to",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    }
                ],
                "name": "FundsWithdrawn",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "uint256",
                        "name": "gameId",
                        "type": "uint256"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "winner",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "betAmount",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "string",
                        "name": "outcome",
                        "type": "string"
                    }
                ],
                "name": "GameConcluded",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "uint256",
                        "name": "gameId",
                        "type": "uint256"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "playerX",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "betAmount",
                        "type": "uint256"
                    }
                ],
                "name": "GameStarted",
                "type": "event"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_gameId",
                        "type": "uint256"
                    }
                ],
                "name": "joinGame",
                "outputs": [],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint8",
                        "name": "_index",
                        "type": "uint8"
                    }
                ],
                "name": "makeMove",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "uint256",
                        "name": "gameId",
                        "type": "uint256"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "player",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint8",
                        "name": "index",
                        "type": "uint8"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint8",
                        "name": "marker",
                        "type": "uint8"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint8[9]",
                        "name": "currentBoard",
                        "type": "uint8[9]"
                    }
                ],
                "name": "MoveMade",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "uint256",
                        "name": "gameId",
                        "type": "uint256"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "playerO",
                        "type": "address"
                    }
                ],
                "name": "PlayerOJoined",
                "type": "event"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_betAmount",
                        "type": "uint256"
                    }
                ],
                "name": "startGame",
                "outputs": [],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "player",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    }
                ],
                "name": "WinningsClaimed",
                "type": "event"
            },
            {
                "stateMutability": "payable",
                "type": "fallback"
            },
            {
                "inputs": [],
                "name": "withdrawOwnerFunds",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "stateMutability": "payable",
                "type": "receive"
            },
            {
                "inputs": [],
                "name": "currentGame",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "playerX",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "playerO",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "betAmount",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint8",
                        "name": "currentTurn",
                        "type": "uint8"
                    },
                    {
                        "internalType": "bool",
                        "name": "gameActive",
                        "type": "bool"
                    },
                    {
                        "internalType": "bool",
                        "name": "gameConcluded",
                        "type": "bool"
                    },
                    {
                        "internalType": "address",
                        "name": "winner",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "gameId",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "owner",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "name": "playerBalances",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        let provider;
        let signer;
        let contract;
        let currentAccount = null;
        let board = ['', '', '', '', '', '', '', '', '']; // Client-side board state
        let currentPlayerMarker = ''; // 'X' or 'O'
        let gameActive = false;
        let currentBetAmount = 0;
        let gameId = null;

        // DOM Elements
        const statusMessage = document.getElementById('status-message');
        const accountInfo = document.getElementById('account-info');
        const gameIdDisplay = document.getElementById('game-id-display');
        const bettingSection = document.getElementById('betting-section');
        const gameActions = document.getElementById('game-actions');
        const joinGameBtn = document.getElementById('join-game-btn');
        const claimWinningsBtn = document.getElementById('claim-winnings-btn');
        const resetGameBtn = document.getElementById('reset-game-btn');
        const gameBoardDiv = document.getElementById('game-board');
        const messageBox = document.getElementById('message-box');

        // Helper to display messages
        function showMessage(msg, type = 'info') {
            messageBox.textContent = msg;
            messageBox.className = `message-box ${type}`;
            messageBox.classList.remove('hidden');
        }

        function hideMessage() {
            messageBox.classList.add('hidden');
        }

        // Initialize Web3
        async function initWeb3() {
            if (typeof window.ethereum !== 'undefined') {
                provider = new ethers.providers.Web3Provider(window.ethereum);
                try {
                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    currentAccount = accounts[0];
                    signer = provider.getSigner();
                    contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
                    statusMessage.textContent = 'Wallet Connected!';
                    accountInfo.textContent = `Account: ${currentAccount.substring(0, 6)}...${currentAccount.substring(currentAccount.length - 4)}`;
                    setupEventListeners();
                    updateUI();
                } catch (error) {
                    console.error("User denied account access or other error:", error);
                    statusMessage.textContent = 'Please connect your wallet to play.';
                    showMessage('Failed to connect wallet. Please ensure MetaMask is installed and unlocked.', 'error');
                }
            } else {
                statusMessage.textContent = 'MetaMask is not installed. Please install it to play.';
                showMessage('MetaMask is not detected. Please install it to use this DApp.', 'error');
            }
        }

        // Setup event listeners for MetaMask account/network changes
        function setupEventListeners() {
            if (window.ethereum) {
                window.ethereum.on('accountsChanged', (accounts) => {
                    currentAccount = accounts[0] || null;
                    if (currentAccount) {
                        signer = provider.getSigner();
                        contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
                        accountInfo.textContent = `Account: ${currentAccount.substring(0, 6)}...${currentAccount.substring(currentAccount.length - 4)}`;
                        updateUI();
                    } else {
                        accountInfo.textContent = '';
                        statusMessage.textContent = 'Wallet Disconnected. Please connect to play.';
                        resetGame();
                    }
                });

                window.ethereum.on('chainChanged', (chainId) => {
                    console.log("Chain changed to:", chainId);
                    // Reload the page or re-initialize based on your DApp's needs
                    window.location.reload();
                });
            }
        }

        // Game UI functions
        function createBoard() {
            gameBoardDiv.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell', 'flex', 'items-center', 'justify-center', 'text-5xl', 'font-bold', 'rounded-lg', 'cursor-pointer', 'transition-all', 'duration-200');
                cell.dataset.index = i;
                cell.addEventListener('click', handleCellClick);
                gameBoardDiv.appendChild(cell);
            }
        }

        function updateBoardUI() {
            const cells = gameBoardDiv.children;
            for (let i = 0; i < 9; i++) {
                cells[i].textContent = board[i];
                cells[i].classList.remove('x', 'o', 'occupied');
                if (board[i] === 'X') {
                    cells[i].classList.add('x', 'occupied');
                } else if (board[i] === 'O') {
                    cells[i].classList.add('o', 'occupied');
                }
            }
        }

        function resetGame() {
            board = ['', '', '', '', '', '', '', '', ''];
            gameActive = false;
            currentPlayerMarker = '';
            gameId = null;
            updateBoardUI();
            gameIdDisplay.textContent = '';
            statusMessage.textContent = 'Select a bet to start a new game or join an existing one!';
            bettingSection.classList.remove('hidden');
            gameActions.classList.add('hidden');
            hideMessage();
        }

        // Game Logic (Client-side for display, contract for truth)
        const winConditions = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
            [0, 4, 8], [2, 4, 6]             // Diagonals
        ];

        function checkWinner() {
            for (let i = 0; i < winConditions.length; i++) {
                const [a, b, c] = winConditions[i];
                if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                    return board[a]; // Returns 'X' or 'O'
                }
            }
            if (!board.includes('')) {
                return 'Draw';
            }
            return null; // No winner yet
        }

        // Web3 Interaction Functions

        async function updateUI() {
            if (!contract || !currentAccount) {
                resetGame();
                return;
            }

            try {
                const currentGameState = await contract.currentGame();
                gameId = (await contract.gameId()).toNumber(); // Get the latest gameId from the contract

                // Check if there's an active game relevant to the current user
                if (currentGameState.gameActive || currentGameState.gameConcluded) {
                    gameIdDisplay.textContent = `Current Game ID: ${gameId}`;
                    bettingSection.classList.add('hidden');
                    gameActions.classList.remove('hidden');

                    // Determine player marker (X or O) for the current user
                    if (currentGameState.playerX.toLowerCase() === currentAccount.toLowerCase()) {
                        currentPlayerMarker = 'X';
                    } else if (currentGameState.playerO.toLowerCase() === currentAccount.toLowerCase()) {
                        currentPlayerMarker = 'O';
                    } else {
                        currentPlayerMarker = ''; // Not part of this game
                    }

                    // Fetch the actual board state from the contract
                    const contractBoard = await provider.call({
                        to: CONTRACT_ADDRESS,
                        data: contract.interface.encodeFunctionData("currentGame", [])
                    });
                    const decodedBoard = contract.interface.decodeFunctionResult("currentGame", contractBoard);
                    const boardArray = decodedBoard[7]; // Assuming board is at index 7 based on ABI (playerX, playerO, betAmount, currentTurn, gameActive, gameConcluded, winner, board)
                    
                    // The ABI doesn't explicitly show 'board' in `currentGame` output.
                    // Let's re-examine the ABI and assume `MoveMade` event's `currentBoard` is the way to get it.
                    // For now, I'll rely on events to update the board.
                    // If `currentGame` doesn't return the board, we'll need to reconstruct it from `MoveMade` events or add a view function to the contract.
                    // For this example, I'll assume the `MoveMade` event is the primary source of board updates.
                    // If the contract's `currentGame` function *does* return the board, this part needs adjustment.
                    // Based on the provided ABI, `currentGame` returns `playerX, playerO, betAmount, currentTurn, gameActive, gameConcluded, winner`. It *does not* return the board state.
                    // This means the client-side board must be updated solely by listening to `MoveMade` events.
                    // For initial load, we'd need to fetch past `MoveMade` events for the current game ID.
                    // To simplify for this example, the board will only update from live events. A full solution would query historical events.

                    gameActive = currentGameState.gameActive;
                    currentBetAmount = ethers.utils.formatEther(currentGameState.betAmount);

                    if (currentGameState.gameConcluded) {
                        if (currentGameState.winner === ethers.constants.AddressZero) {
                            statusMessage.textContent = `Game ${gameId} concluded: Draw!`;
                        } else if (currentGameState.winner.toLowerCase() === currentAccount.toLowerCase()) {
                            statusMessage.textContent = `Game ${gameId} concluded: You Won! Claim your winnings!`;
                            claimWinningsBtn.classList.remove('hidden');
                        } else {
                            statusMessage.textContent = `Game ${gameId} concluded: ${currentGameState.winner.substring(0, 6)}... won.`;
                        }
                        gameBoardDiv.querySelectorAll('.cell').forEach(cell => cell.removeEventListener('click', handleCellClick));
                    } else if (gameActive) {
                        statusMessage.textContent = `Game ${gameId} Active! Turn: ${currentGameState.currentTurn === 1 ? 'X' : 'O'}`;
                        if (currentGameState.playerX.toLowerCase() === currentAccount.toLowerCase() && currentGameState.currentTurn === 1) {
                            statusMessage.textContent += ' (Your Turn - X)';
                        } else if (currentGameState.playerO.toLowerCase() === currentAccount.toLowerCase() && currentGameState.currentTurn === 2) {
                            statusMessage.textContent += ' (Your Turn - O)';
                        } else {
                            statusMessage.textContent += ' (Waiting for opponent)';
                        }
                        claimWinningsBtn.classList.add('hidden');
                    } else {
                        statusMessage.textContent = `Game ${gameId} created by ${currentGameState.playerX.substring(0, 6)}... Waiting for Player O.`;
                        if (currentGameState.playerX.toLowerCase() !== currentAccount.toLowerCase()) {
                            joinGameBtn.classList.remove('hidden');
                        } else {
                            joinGameBtn.classList.add('hidden');
                        }
                        claimWinningsBtn.classList.add('hidden');
                    }
                } else {
                    resetGame(); // No active game for this user
                }
            } catch (error) {
                console.error("Error updating UI from contract:", error);
                showMessage("Error fetching game state. Please refresh or check console.", "error");
                resetGame();
            }
        }

        async function startGame(betAmount) {
            if (!contract || !currentAccount) {
                showMessage("Wallet not connected.", "error");
                return;
            }
            showMessage("Starting game... Please confirm transaction in MetaMask.", "info");
            try {
                const value = ethers.utils.parseEther(betAmount.toString());
                const tx = await contract.startGame(value, { value: value });
                showMessage(`Transaction sent: ${tx.hash}. Waiting for confirmation...`, "info");
                await tx.wait();
                showMessage("Game started successfully! Waiting for another player to join.", "success");
                // The UI will be updated by the GameStarted event listener
            } catch (error) {
                console.error("Error starting game:", error);
                showMessage(`Failed to start game: ${error.message || error.code}`, "error");
            }
        }

        async function joinGame() {
            if (!contract || !currentAccount || gameId === null) {
                showMessage("Wallet not connected or no game to join.", "error");
                return;
            }
            showMessage("Joining game... Please confirm transaction in MetaMask.", "info");
            try {
                const currentGameState = await contract.currentGame();
                const value = currentGameState.betAmount; // Use the bet amount from the existing game
                const tx = await contract.joinGame(gameId, { value: value });
                showMessage(`Transaction sent: ${tx.hash}. Waiting for confirmation...`, "info");
                await tx.wait();
                showMessage("Successfully joined the game!", "success");
                // The UI will be updated by the PlayerOJoined event listener
            } catch (error) {
                console.error("Error joining game:", error);
                showMessage(`Failed to join game: ${error.message || error.code}`, "error");
            }
        }

        async function handleCellClick(event) {
            if (!gameActive || !contract || !currentAccount) {
                showMessage("Game is not active or wallet not connected.", "error");
                return;
            }

            const index = parseInt(event.target.dataset.index);
            if (board[index] !== '') {
                showMessage("Cell already occupied!", "info");
                return;
            }

            const currentGameState = await contract.currentGame();
            const turn = currentGameState.currentTurn; // 1 for X, 2 for O
            const playerX = currentGameState.playerX.toLowerCase();
            const playerO = currentGameState.playerO.toLowerCase();

            // Check if it's the current player's turn
            if ((currentPlayerMarker === 'X' && turn !== 1) || (currentPlayerMarker === 'O' && turn !== 2)) {
                showMessage("It's not your turn!", "info");
                return;
            }

            showMessage(`Making move at index ${index}... Please confirm transaction in MetaMask.`, "info");
            try {
                const tx = await contract.makeMove(index);
                showMessage(`Transaction sent: ${tx.hash}. Waiting for confirmation...`, "info");
                await tx.wait();
                showMessage("Move made successfully!", "success");
                // The board will be updated by the MoveMade event listener
            } catch (error) {
                console.error("Error making move:", error);
                showMessage(`Failed to make move: ${error.message || error.code}`, "error");
            }
        }

        async function concludeGame(winnerAddress, isDraw) {
            if (!contract || !currentAccount || !gameActive) {
                showMessage("Game not active or wallet not connected.", "error");
                return;
            }
            showMessage("Concluding game... Please confirm transaction in MetaMask.", "info");
            try {
                const tx = await contract.concludeGame(winnerAddress, isDraw);
                showMessage(`Transaction sent: ${tx.hash}. Waiting for confirmation...`, "info");
                await tx.wait();
                showMessage("Game concluded on chain!", "success");
                // UI will update via GameConcluded event
            } catch (error) {
                console.error("Error concluding game:", error);
                showMessage(`Failed to conclude game: ${error.message || error.code}`, "error");
            }
        }

        async function claimWinnings() {
            if (!contract || !currentAccount) {
                showMessage("Wallet not connected.", "error");
                return;
            }
            showMessage("Claiming winnings... Please confirm transaction in MetaMask.", "info");
            try {
                const tx = await contract.claimWinnings();
                showMessage(`Transaction sent: ${tx.hash}. Waiting for confirmation...`, "info");
                await tx.wait();
                showMessage("Winnings claimed successfully!", "success");
                claimWinningsBtn.classList.add('hidden'); // Hide button after claiming
            } catch (error) {
                console.error("Error claiming winnings:", error);
                showMessage(`Failed to claim winnings: ${error.message || error.code}`, "error");
            }
        }

        // Contract Event Listeners
        function listenToContractEvents() {
            if (contract) {
                contract.on("GameStarted", (gameIdEvent, playerX, betAmount, event) => {
                    console.log("GameStarted Event:", { gameIdEvent: gameIdEvent.toString(), playerX, betAmount: ethers.utils.formatEther(betAmount) });
                    gameId = gameIdEvent.toNumber();
                    showMessage(`Game ${gameId} started by ${playerX.substring(0, 6)}... Bet: ${ethers.utils.formatEther(betAmount)} STT`, "success");
                    updateUI(); // Refresh UI to reflect new game state
                });

                contract.on("PlayerOJoined", (gameIdEvent, playerO, event) => {
                    console.log("PlayerOJoined Event:", { gameIdEvent: gameIdEvent.toString(), playerO });
                    showMessage(`Player O (${playerO.substring(0, 6)}...) joined Game ${gameIdEvent.toString()}! Game is now active.`, "success");
                    gameActive = true;
                    updateUI(); // Refresh UI
                });

                contract.on("MoveMade", (gameIdEvent, player, index, marker, currentBoard, event) => {
                    console.log("MoveMade Event:", { gameIdEvent: gameIdEvent.toString(), player, index, marker, currentBoard });
                    // Update client-side board based on the event
                    board = currentBoard.map(val => {
                        if (val === 1) return 'X';
                        if (val === 2) return 'O';
                        return '';
                    });
                    updateBoardUI();

                    const winner = checkWinner();
                    if (winner) {
                        gameActive = false;
                        if (winner === 'Draw') {
                            statusMessage.textContent = `Game ${gameIdEvent.toString()}: It's a Draw!`;
                            concludeGame(ethers.constants.AddressZero, true); // Conclude as draw
                        } else {
                            const winnerAddress = (winner === 'X' ? contract.currentGame().then(g => g.playerX) : contract.currentGame().then(g => g.playerO));
                            winnerAddress.then(addr => {
                                statusMessage.textContent = `Game ${gameIdEvent.toString()}: ${winner} Wins!`;
                                concludeGame(addr, false); // Conclude with winner
                            });
                        }
                        gameBoardDiv.querySelectorAll('.cell').forEach(cell => cell.removeEventListener('click', handleCellClick));
                    } else {
                        updateUI(); // Update turn info
                    }
                });

                contract.on("GameConcluded", (gameIdEvent, winner, betAmount, outcome, event) => {
                    console.log("GameConcluded Event:", { gameIdEvent: gameIdEvent.toString(), winner, betAmount: ethers.utils.formatEther(betAmount), outcome });
                    showMessage(`Game ${gameIdEvent.toString()} concluded. Outcome: ${outcome}. Winner: ${winner === ethers.constants.AddressZero ? 'Draw' : winner.substring(0, 6) + '...'}.`, "success");
                    gameActive = false;
                    updateUI(); // Refresh UI to show claim winnings button if applicable
                });

                contract.on("WinningsClaimed", (player, amount, event) => {
                    console.log("WinningsClaimed Event:", { player, amount: ethers.utils.formatEther(amount) });
                    showMessage(`Successfully claimed ${ethers.utils.formatEther(amount)} STT!`, "success");
                    updateUI();
                });

                console.log("Listening to contract events...");
            }
        }

        // Event Listeners for UI buttons
        document.querySelectorAll('.bet-option').forEach(button => {
            button.addEventListener('click', async (e) => {
                const bet = parseFloat(e.target.dataset.bet);
                await startGame(bet);
            });
        });

        joinGameBtn.addEventListener('click', joinGame);
        claimWinningsBtn.addEventListener('click', claimWinnings);
        resetGameBtn.addEventListener('click', resetGame);

        // Initial setup
        window.onload = () => {
            createBoard();
            initWeb3();
        };

    </script>
</body>
</html>
